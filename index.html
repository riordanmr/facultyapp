<!DOCTYPE html>
<html>
<!-- This is a recreation, in HTML and JavaScript, of Davis Gries's FacultyApplet,
    a Java applet which displays a list of Cornell Computer Science Department faculty members.
    See the original at https://www.cs.cornell.edu/gries/facultyunix/first.html.
    The motivation behind this rewrite is to support modern browsers; these days, browsers
    won't run Java applets. 

    The original FacultyApplet was surprisingly elaborate, given its relatively simple purpose.
    Presumably it was written to gain familiarity with Java, or as a demonstration of Java.
    This version attempts to recreate the functionality and appearance of the original 
    as accurately as reasonably possible.

    Much of the code here is a translation of the original Java code to JavaScript.
    Several automated tools were used to aid in the conversion of the Java code to JavaScript, 
    including codeconvert.ai, blackbox.ai, www.stratacode.com/javaToJS/online.html, and 
    Github Copilot.
    There was also a fair bit of manual coding.
    
    Mark Riordan  January 2024  riordan@rocketmail.com
    Released under the MIT License.

    This source code is at https://github.com/riordanmr/facultyapp/
    and is deployed at https://riordanmr.github.io/facultyapp/
--> 
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="shortcut icon" href="favicon.ico" />
    <title>FacultyApp</title>
    <style>
        .topfont {
            font-family: Arial,sans-serif;
            font-size: 10pt;
        }
    
        .topinstructions {
            text-align: center;
            width: 800px;
            margin-bottom: 4px;
        }
    
        #canvasMain {
            border: none;
            padding: 0px;
            margin: 0px;
        }
    
        #scrollbarvert {
            border: none;
            padding: 0px;
            margin: 0px;
        }

        #scrollbarHorz {
            border: none;
            padding: 0px;
            margin: 0px;
        }

        #dlgAbout {
            background-color: #fafad2;
            font-family: Arial, sans-serif;
        }

       /* The Close Button */
       .close {
            color: black;
            position: absolute;
            top: 0em;
            right: 0.33em;
            font-size: 1.5em;
            font-weight: bold;
            padding: 0px;
            cursor: pointer;
       }

        .authorindent {
            margin-left: 1em;
        }

        .author p {
            margin: 0.4em 0;
        }

        .bigvertspace {
            line-height: 150%;
        }
    
        .tablenopadding {
            border-spacing: 0 !important;
            border-collapse: collapse !important;
            margin: 0 !important;
        }
    
        .cellnopadding {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
            font-size: 0pt; 
            line-height: 0px;
        }
    </style>
    <!-- This is the equivalent of the embedded resource faclist.txt.  
        Here is the original documentation for faclist.txt:
        
        The faculty appear in faclist.txt in any
        order. For each person, give the following information:
        
            Name, with character '=' instead of a blank --the name may
            not contain a blank.
                
            Description of a period of service.         (These descriptions must
            Description of next period of service.  appear in chronological
            ...                                     order and have no overlap)
            Description of last period of service.
            A period "."
        
        A description of a period of service consists of:
        
            An optional leave thing: "SAB" for sabbatic and "LEA" for other leaves
        
            A title: "L" for lecturer,
                        "SL" for senior lecturer,
                        "I"  for instructor,
                        "A1" for assistant professor,
                        "A2" for associate professor,
                        "FP" for full professor,
                        "EP" for professor emeritus
                        "F"  for a member of the Field of CS who is not a member
                            of the department
            The first semester of the period  (e.g. F 1989  or  S 1965)
            The last semester of the period (e.g. S 1989). If the last semester is
                the current one and the person is expected to be on the faculty
                in the next semester, use "present" for the last semester.
            
        SEPARATE EACH PIECE OF DATA BY AT LEAST ONE BLANK OR BY AN END-OF-LINE.        
    -->
    <script type="text/javascript" src="faclist.js"></script>
    <!-- Class to implement scrollbars. -->
    <script type="text/javascript" src="CSScrollbar.js"></script>
</head>

<body>
    <!-- HTML text and controls -->
    <div class="topfont topinstructions">CS FACULTY OVER THE YEARS! &nbsp; Choose a range of years and a sort key and
        press OK.</div>
    <div class="topfont">&nbsp;</div>
    <div class="topfont topinstructions">To sort on x with secondary keys y and z, first sort on z, then y, then x.
    </div>
    <div class="topfont">&nbsp;</div>
    <div class="topfont topinstructions">First:&nbsp; <select name="selfirst" id="selfirst">
        </select>
        &nbsp;&nbsp;Last:&nbsp; <select name="sellast" id="sellast">
        </select>
        &nbsp;&nbsp;Sort by:&nbsp;
        <select name="selsortby" id="selsortby">
            <option value="name">name</option>
            <option value="first semester">first semester</option>
            <option value="last semester">last semester</option>
            <option value="time in dept.">time in dept.</option>
            <option value="title">title</option>
        </select>
        &nbsp;&nbsp;<button id="btnok" onclick="onOK();">OK</button>
        &nbsp;&nbsp;<button id="btnabout">About ...</button>
    </div>
    <dialog id="dlgAbout">
        <div>
            <span onclick="document.getElementById('dlgAbout').close()" class="close">&times;</span>
            <div class="bigvertspace">Original version developed by</div>
            <div class="authorindent bigvertspace">
                David Gries<br/>
                Computer Science, Upson Hall<br/>
                Cornell University<br/>
                Ithaca, NY 14853<br/>
                gries@cs.cornell.edu
            </div>
            <div class="bigvertspace">JavaScript version by</div>
            <div class="authorindent bigvertspace">
                Mark Riordan<br/>
                riordan@rocketmail.com
            </div>
            <div class="bigvertspace">See 
                <a href="https://www.cs.cornell.edu/gries/facultyunix/first.html">https://www.cs.cornell.edu/gries/facultyunix/first.html</a><br/>
                for information about the original applet.</div>
        </div>
    </dialog>

    <!-- The canvas for the main display, plus canvases for the scrollbars -->
    <table class="tablenopadding">
        <tr>
          <td class="cellnopadding"><canvas id="canvasMain" width="800" height="460"></canvas></td>
          <td class="cellnopadding"><canvas id="scrollbarVert" width="15" height="460"></canvas></td>
        </tr>
        <tr>
            <td class="cellnopadding"><canvas id="scrollbarHorz" width="800" height="15"></canvas></td>
            <td class="cellnopadding"></td>
        </tr>
      </table>
      
    <script>
        // Constants to identify sort keys.
        const BYNAME = 0;
        const BYFIRSTSEMESTER = 1;
        const BYLASTSEMESTER = 2;
        const BYLENGTH = 3;
        const BYTITLE = 4;

        const LASTYEAR = 1998;

        // Given a context, compute the number of pixels between consecutive lines of text,
        // including any necessary leading.
        // Thanks to https://stackoverflow.com/questions/1134586
        function computeFontHeight(ctx) {
            let metrics = ctx.measureText("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ");
            let fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
            let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
            return 1.07 * actualHeight;
        }

        // Convert red, green, blue integers to an HTML color code.
        function rgb(r, g, b) {
            const toHex = n => n.toString(16).padStart(2, '0');
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }

        // Class to represent a pair of integer values x and y.
        // Converted from Coordinates.java by blackbox.ai:
        class Coordinates {
            constructor(h, k) {
                this.x = h;
                this.y = k;
            }
        }

        // A representation of a semester
        // (e.g. Fall 1997 or Spring 1998)
        // Converted from Semester.java by codeconvert.ai
        class Semester {
            // Constructor --the semester that is in month m and 4-digit year y.
            // Months 0..5 are the spring semester; months 6..11, fall semester
            constructor(m, y) {
                this.yr = y;
                if (m <= 5) this.sem = 0;
                else this.sem = 1;
            }

            // Yield the semester, as a String "F" or "S"
            semester() {
                if (this.sem === 0) return "S";
                return "F";
            }

            // Set the semester to t (which is "F" or "S")
            setSemester(t) {
                if (t === "S")
                    this.sem = 0;
                else this.sem = 1;
            }

            // Yield the year
            year() {
                return this.yr;
            }

            // Set the year to i
            setYear(i) {
                this.yr = i;
            }

            // = Semester s1 comes before or is the same as Semester s2
            static lesseq(s1, s2) {
                if (s1.year() < s2.year()) return true;
                if (s1.year() > s2.year()) return false;
                return s1.sem <= s2.sem;
            }

            // = Semester s1 comes before Semester s2
            static less(s1, s2) {
                if (s1.year() < s2.year()) return true;
                if (s1.year() > s2.year()) return false;
                return s1.sem < s2.sem;
            }

            // = Semesters s1 and s2 are the same
            static equals(s1, s2) {
                return s1.yr === s2.yr && s1.sem === s2.sem;
            }

            // = the Semester following this Semester
            next() {
                let s = new Semester();
                s.yr = this.yr;
                s.sem = 1 - this.sem;
                if (s.sem === 0)
                    s.yr = s.yr + 1;
                return s;
            }

            // = the number of Semesters between Semesters s1 and s2  --i.e.
            //   the number of times s1.next() is to be executed to get to s2
            //   (Precondition: lesseq(s1, s2); otherwise, 0 is returned)
            static difference(s1, s2) {
                if (this.less(s2, s1)) return 0;
                if (s1.sem === s2.sem)
                    return 2 * (s2.yr - s1.yr);
                return 1 + 2 * (s2.yr - s1.next().yr);
            }

            // = the minimum of Semesters s1 and s2
            static min(s1, s2) {
                if (this.lesseq(s1, s2)) return s1;
                return s2;
            }

            // = the maximum of Semesters s1 and s2
            static max(s1, s2) {
                if (this.lesseq(s1, s2)) return s2;
                return s1;
            }

            // = a String version of this Semester
            toString() {
                if (this.sem === 0) return "S" + this.yr;
                return "F" + this.yr;
            }
        }

        // A node of a linked list (or class LinkedList)
        class LinkedListNode {
            constructor(value = null) {
                this.value = value;
                this.next = null;
            }
        }

        // Class of the base of a linked list, with head/tail
        // pointers, with objects that are owned by the list
        class LinkedList {
            // Constructor: a list with one node with value value
            constructor(value = null) {
                if (value === null) {
                    this.head = null;
                    this.tail = null;
                } else {
                    this.head = new LinkedListNode(value);
                    this.tail = this.head;
                }
                this.sz = value === null ? 0 : 1;
            }

            // Prepend value to list
            prepend(value) {
                const newNode = new LinkedListNode(value);
                newNode.next = this.head;
                this.head = newNode;
                if (this.tail === null) {
                    this.tail = newNode;
                }
                this.sz++;
            }

            // Change the value of the first entry of the
            // nonempty list to value
            change(value) {
                if (this.head !== null) {
                    this.head.value = value;
                }
            }

            // Append value to list
            append(value) {
                if (this.head === null) {
                    this.head = new LinkedListNode(value);
                    this.tail = this.head;
                } else {
                    this.tail.next = new LinkedListNode(value);
                    this.tail = this.tail.next;
                }
                this.sz++;
            }

            // Remove first element of list and return it --return
            // null if list is empty
            remove() {
                if (this.head === null) {
                    return null;
                }
                const value = this.head.value;
                this.head = this.head.next;
                this.sz--;
                if (this.head === null) {
                    this.tail = null;
                }
                return value;
            }

            // = first element of list (or null if list is empty)
            // It should not be changed, but only inspected
            inspect() {
                return this.head === null ? null : this.head.value;
            }

            // = element n of the list (or null if not possible)
            // Precondition: 0<= n< this.size()
            inspectAt(index) {
                let current = this.head;
                let i = 0;
                while (i < index && current !== null) {
                    current = current.next;
                    i++;
                }
                return current === null ? null : current.value;
            }

            // = last element of list (or null if list is empty)
            // The element should not be changed, but only inspected
            inspectLast() {
                return this.tail === null ? null : this.tail.value;
            }

            // = list is empty
            isEmpty() {
                return this.head === null;
            }

            // = size of list
            size() {
                return this.sz;
            }

            // Set the list to an empty list
            clear() {
                this.head = null;
                this.tail = null;
                this.sz = 0;
            }

            // Return the list but truncated to its first n elements
            // Precondition: 0 <= n <= this.size()
            truncate(n) {
                if (n === 0) {
                    this.clear();
                    return this;
                }
                this.sz = n;
                let current = this.head;
                while (n !== 1) {
                    n--;
                    current = current.next;
                }
                this.tail = current;
                this.tail.next = null;
                return this;
            }

            // Remove and return last element of the list (return null
            // if none). This method is inefficient, because of the
            // list's structure.
            removeLast() {
                if (this.sz === 0) {
                    return null;
                }
                if (this.sz === 1) {
                    const value = this.head.value;
                    this.head = null;
                    this.tail = null;
                    this.sz--;
                    return value;
                }
                let current = this.head;
                while (current.next !== this.tail) {
                    current = current.next;
                }
                const value = this.tail.value;
                this.tail = current;
                this.tail.next = null;
                this.sz--;
                return value;
            }

            // a printable version of the elements of this LinkedList
            // --assuming that toString() works for its elements
            toString() {
                let current = this.head;
                let str = "(";
                let isFirst = true;
                while (current !== null) {
                    if (!isFirst) {
                        str += ", ";
                    }
                    isFirst = false;
                    str += current.value;
                    current = current.next;
                }
                return str + ")";
            }
        }

        // Provide methods for iterating over objects
        // in a LinkedList list
        class LinkedListIterator {
            // Constructor: to iterate over list s
            constructor(linkedList) {
                // head of the list
                this.head = linkedList.head;
                // current node to be processed
                // (null if none)
                this.node = this.head;
                // index of current node (first is 0)
                this.index = 0;
            }

            // change the current node to the beginning of the list
            reset() {
                this.node = this.head;
                this.index = 0;
            }

            // = "current node is non-null"
            okay() {
                return this.node !== null;
            }

            // = value of current node --call only if node is non-null
            data() {
                return this.node.value;
            }

            // = change the current node to the next one in the list
            //   (or null if there is no next one)
            next() {
                if (this.node !== null) {
                    this.node = this.node.next;
                    this.index++;
                }
            }

            // = index of current element (0 if past end of list)
            getIndex() {
                return this.node !== null ? this.index : 0;
            }
        }


        // A dynamic array of elements of class Faculty
        // Converted from DynArray.java by codeconvert.ai
        class DynArray {
            // sort0, sort1, and sort2 are used to define a sorting order.
            // Each is one of the values CSCanvas.BYNAME--CS_Canvas.BYTITLE
            // When an array is to be sorted, these values are used: sort0 defines
            // the first sort key, sort1 the second, and sort2 the third.  These
            // variables are static so that, when a copy is made of the array,
            // the current values are used. They are changed in method sort.
            static sort0 = BYNAME;  // Initally, all say sort on name
            static sort1 = BYNAME;
            static sort2 = BYNAME;

            // Constructor: an array of 0 elements but allocation 10
            constructor() {
                this.b = new Array(10);
                this.sz = 0;
            }

            // Add element f to the array
            add(f) {
                if (this.sz === this.b.length) {
                    let bTemp = this.b;
                    this.b = new Array(this.b.length * 4);
                    if (this.sz > 0) {
                        bTemp.slice(0, this.sz).forEach((item, index) => {
                            this.b[index] = item;
                        });
                    }
                }
                this.b[this.sz] = f;
                this.sz += 1;
            }

            // = element i of the array
            // Precondition: 0<=i<sz
            element(i) {
                return this.b[i];
            }

            // = number of filled elements in the array (not the number allocated)
            size() {
                return this.sz;
            }

            // = String verson of elements of the array
            toString() {
                let s = '';
                for (let i = 0; i < this.sz; i++) {
                    s += "\n" + this.b[i].toString();
                }
                return s;
            }

            // Swap b[i] and b[k]
            swap(i, k) {
                let temp = this.b[i];
                this.b[i] = this.b[k];
                this.b[k] = temp;
            }

            // Remove element i from the array (put the last element in its place)
            // It is assumed that 0 <= i < this.size().
            remove(i) {
                this.b[i] = this.b[this.sz - 1];
                this.sz -= 1;
            }

            // = "x came before y"
            static cameBefore(x, y) {
                return Semester.less(x.firstSemester(), y.firstSemester());
            }

            // = x left before y
            static leftBefore(x, y) {
                return Semester.less(x.lastSemester(), y.lastSemester());
            }

            // sort0,sort1,sort2:= sortChoice,sort0,sort1, where sortChoice is
            // one of the values CSCanvas.BYNAME--CSCanvas.BYTITLE.
            // Then sort this array based on sort0, sort1, sort2
            sort(sortChoice) {
                DynArray.sort2 = DynArray.sort1;
                DynArray.sort1 = DynArray.sort0;
                DynArray.sort0 = sortChoice;
                this.quickSort();
            }

            // = a copy of the array
            copy() {
                let c = new DynArray();
                for (let i = 0; i < this.sz; i++) {
                    c.add(this.b[i]);
                }
                return c;
            }

            // = the number of faculty in the array whose lastTitle field is tt
            numTitle(tt) {
                let n = 0;
                for (let i = 0; i < this.sz; i++) {
                    if (this.element(i).lastTitle === tt) {
                        n += 1;
                    }
                }
                return n;
            }

            // 0 <= h < k-1 < this.size(). Let x some value in this[h..k-1]
            // Permute this[h..k-1] and return a value p such that
            // this[h..p-1] <= x = p <= this[p+1..k-1]
            partition(h, k) {
                // Permute this.h, this[(h+k)/2], this[k-1] so that b.h is the median
                // (code still to be written)
                let q = h + 1;
                let p = k - 1;
                // invariant: this.h=x, this[h+1..q-1]<=x, and this[p+1..k-1]>=x
                while (q <= p) {
                    if (this.lessTest(q, h)) {
                        q += 1;
                    } else if (this.lessTest(h, p)) {
                        p -= 1;
                    } else {
                        this.swap(p, q);
                        q += 1;
                        p -= 1;
                    }
                }
                if (p + 2 === q) {
                    p += 1;
                }
                // Result: this.h=x, this[h+1..p]<=x, this[p+1..k-1]>=x
                this.swap(h, p);
                return p;
            }

            // Sort this array, inplace, using Quicksort, where based on globals s0 and s1
            quickSort() {
                let t = new LinkedList();
                // Invariant: The array is sorted if each of the segments
                //             this[e.x .. e.y-1] are sorted for e an element of t
                t.append(new Coordinates(0, this.size()));

                while (t.size() !== 0) {
                    let co = t.remove();
                    let h = co.x;
                    let k = co.y;
                    if (k === h) {                      // Partition of size 0
                        // Do nothing
                    } else if (k - h <= 2) {
                        if (this.lessTest(k - 1, h)) {  // Partition of size 1 or 2
                            this.swap(k - 1, h);
                        }
                    } else {                            // Partition of size > 2
                        let j = this.partition(h, k);
                        // this[h..j-1]<=this.j<=this[j+1..k-1]
                        // Place the larger of the two segments on t first, then the smaller                        
                        if (k - j - 1 > j - h) {
                            t.prepend(new Coordinates(j + 1, k));
                            t.prepend(new Coordinates(h, j));
                        } else {
                            t.prepend(new Coordinates(h, j));
                            t.prepend(new Coordinates(j + 1, k));
                        }
                    }
                }
            }

            //= b[i]<b[j], where < is defined depending on s:
            // 0=name,1=title,2=first sem, 3=last sem, 4=length of stay
            less(i, j, s) {
                switch (s) {
                    case BYNAME:
                        return this.b[i].name.localeCompare(this.b[j].name) < 0;
                    case BYTITLE:
                        return this.b[j].lastTitle < this.b[i].lastTitle;
                    case BYFIRSTSEMESTER:
                        return DynArray.cameBefore(this.b[i], this.b[j]);
                    case BYLASTSEMESTER:
                        return DynArray.leftBefore(this.b[j], this.b[i]);
                    case BYLENGTH:
                        return this.b[j].numSemesters() < this.b[i].numSemesters();
                    default:
                        return true;
                }
            }

            // = b[i]<b[j], where < is defined depending on sort0, sort1, sort2 (see
            // their definition)
            lessTest(i, j) {
                if (this.less(i, j, DynArray.sort0)) return true;
                if (this.less(j, i, DynArray.sort0)) return false;
                // b[i] = b[j] on first key
                if (this.less(i, j, DynArray.sort1)) return true;
                if (this.less(j, i, DynArray.sort1)) return false;
                // b[i] = b[j] on second key
                return this.less(i, j, DynArray.sort2);
            }
        }
        
        // Given a string, break it into tokens and return them one at a time.
        class Tokenizer {
            constructor(str, delimiters) {
                this.str = str;
                this.index = 0;
                this.delimiters = delimiters;
            }

            hasMoreTokens() {
                // Skip delimiters.
                while(this.index < this.str.length && this.delimiters.indexOf(this.str[this.index]) !== -1) {
                    this.index++;
                }
                return this.index < this.str.length;
            }

            nextToken() {
                if (this.index >= this.str.length) {
                    return null;
                }

                // Skip to beg of next token.
                while (this.index < this.str.length && this.delimiters.indexOf(this.str[this.index]) !== -1) {
                    this.index++;
                }

                let startIndex = this.index;
                while (this.index < this.str.length && this.delimiters.indexOf(this.str[this.index]) === -1) {
                    this.index++;
                }

                let token = this.str.substring(startIndex, this.index);
                if (token.length === 0) {
                    return null;
                }

                return token;
            }
        }

        // A tokenizer that reads integers and "words", where a word
        // is a sequence of non-whitespace characters.
        class GriesTokenizer extends Tokenizer {
            // Constructor --tokenize s
            constructor(s) {
                super(s, "\n\t\r ");
            }

            // return the next token as an integer
            nextIntToken() {
                const s = this.nextToken();
                if (!this.isDigits(s)) return -1;
                return parseInt(s);
            }

            // = s consists solely of digits 0..9
            isDigits(s) {
                for (let i = 0; i < s.length; i++) {
                    if (s.charCodeAt(i) < 48) return false;
                    if (s.charCodeAt(i) > 57) return false;
                }
                return true;
            }

            // return the next word --as explained above.
            nextWord() {
                const s = this.nextToken();
                if (s.charAt(0) !== '"') return s;
                // Word begins with ", so parse a real string
                s = s.substring(1);
                while (s.charAt(s.length - 1) !== '"') {
                    s = s + " " + this.nextToken();
                }
                return s.substring(0, s.length - 1);
            }
        }

        // A period of time at a certain title
        class TitleTime {
            // Constants. All constants will always be in a contiguous range 1.. .
            // Don't change ordering of these constants.            
            static FIELD = 1;
            static LECTURER = 2;
            static SRLECTURER = 3;
            static INSTRUCTOR = 4;
            static ASSTPROF = 5;
            static ASSOCPROF = 6;
            static FULLPROF = 7;
            static EMERITUS = 8;
            static numTitles = 8;  // Number of different titles

            // Leave status constants
            static NOLEAVE = 1;     // Not on leave during the period
            static SABBATIC = 2;    // On sabbatic during the period
            static OTHERLEAVE = 3;  // On other leave during the period

            // Constructor: a time at title t, status st, beginning in semester s1
            // and ending in semester s2. st is one of the constants NOLEAVE, SABBATIC,
            // or OTHERLEAVE.
            constructor(t, s1, s2, st = TitleTime.NOLEAVE) {
                this.firstSemester = s1;
                this.lastSemester = s2;
                this.title = t;         // One of the constants LECTURER--FIELD
                this.status = st;       // NOLEAVE, SABBATIC, or OTHERLEAVE
            }

            // a String version of title
            static makeTitle(title) {
                switch (title) {
                    case TitleTime.LECTURER: return "Lecturer";
                    case TitleTime.SRLECTURER: return "Sr. Lecturer";
                    case TitleTime.INSTRUCTOR: return "Instructor";
                    case TitleTime.ASSTPROF: return "Assis. Prof.";
                    case TitleTime.ASSOCPROF: return "Assoc. Prof.";
                    case TitleTime.FULLPROF: return "Full Prof.";
                    case TitleTime.EMERITUS: return "Prof. Emeritus";
                    case TitleTime.FIELD: return "Field Member";
                    default: return "Error. unknown";
                }
            }

            // Set the leave status to st (one of the three status constants)
            setStatus(st) {
                this.status = st;
            }

            // a String version of the title of this TitleTime
            makeTitle() {
                return TitleTime.makeTitle(this.title);
            }

            // A String version of the status during this period
            makeStatus() {
                switch (this.status) {
                    case TitleTime.NOLEAVE: return "noleave";
                    case TitleTime.SABBATIC: return "sabbatic";
                    case TitleTime.OTHERLEAVE: return "leave";
                    default: return "Error: status " + this.status + " unknown";
                }
            }

            // A String version of this TitleTime
            toString() {
                return `${this.makeTitle()} ${this.makeStatus()} ${this.firstSemester}--${this.lastSemester}`;
            }

            // = the Color for this title
            titleColor() {
                switch (this.title) {
                    case TitleTime.LECTURER: return rgb(52,236,2);
                    case TitleTime.SRLECTURER: return rgb(2,140,12);
                    case TitleTime.INSTRUCTOR: return rgb(56,50,247);
                    case TitleTime.ASSTPROF: return rgb(250,173,110);
                    case TitleTime.ASSOCPROF: return rgb(250,44,28);
                    case TitleTime.FULLPROF: return rgb(149,14,4);
                    case TitleTime.EMERITUS: return rgb(89,89,89);
                    case TitleTime.FIELD: return rgb(104,217,249);
                    default: return rgb(0,0,0);
                }
            }

            // = the Color for title t (one of the above constants)
            static titleColor(t) {
                let temp = new TitleTime(t, null, null);
                return temp.titleColor();
            }
        }

        // Record of a faculty member:
        // name and a list of time periods with titles.
        // These must be in chronological order and must not overlap.
        class Faculty {
            // Constructor --a faculty member with name name, title t, leave-status st,
            //               first semester s1, and last Semester s2.). s1,s2 are Semester
            //               objects; t is one of the size constants of class TitleTime.
            constructor(name, t, st, s1, s2) {
                this.name = name;
                // A linked list of periods of the faculty member. There
                // is more than one element either because the member was in service at
                // noncontiguous periods or because their title changed. Elements of
                // the linked list are of type TitleTime.
                this.periods = new LinkedList();
                if (st !== null) {
                    this.periods.append(new TitleTime(t, s1, s2, st));
                } else {
                    this.periods.append(new TitleTime(t, s1, s2));
                }

                // The last title for this faculty member in the
                // range associated with the array in which it appears
                this.lastTitle = t;
            }

            // Add a new period for this person --title t, status st, first semester s1, and
            // second semester s2
            addPeriod(t, st, s1, s2) {
                this.periods.append(new TitleTime(t, s1, s2, st));
                this.lastTitle = t;
            }

            // = String version of this faculty member
            toString() {
                var res= this.name;
                let iter= new LinkedListIterator(this.periods);
                while (iter.okay()) {
                    let tt= iter.data();
                    res= res + " " + tt.toString();
                    iter.next();
                }

                return res;
            }

            // First semester for this faculty member
            firstSemester() {
                return this.periods.inspect().firstSemester;
            }

            // Last semester for this faculty member
            lastSemester() {
                return this.periods.inspectLast().lastSemester;
            }

            // = Number of semesters at Cornell (Does not count non-sabbatical leaves)
            numSemesters() {
                var num = 0;
                var iter = new LinkedListIterator(this.periods);
                while (iter.okay()) {
                    var tt = iter.data();
                    if (tt.status !== TitleTime.OTHERLEAVE)
                        num = num + Semester.difference(tt.firstSemester, tt.lastSemester) + 1;
                    iter.next();
                }
                return num;
            };

            // = the last title for the faculty member that within the bounds of the currently
            //  displayed years
            // Precondition: at least one semester of the faculty member is within the bounds
            lastTitle() {
                let ans = 0;
                let iter = this.periods[Symbol.iterator]();
                let result;
                // Invariant and is the last title within bounds for the elements of periods
                // looked at thus far (0 if none)
                while (!(result = iter.next()).done) {
                    let tt = result.value;
                    if (CSCanvas.isWithin(tt)) {
                        ans = tt.title;
                    }
                }

                return ans;
            }
        }

        // Represents the canvas on which the faculty members are displayed; does not
        // include the scrollbars.  The canvas is divided into two parts: the top part
        // contains the headers, and the bottom part contains the faculty members.
        class CSCanvas /*extends Canvas*/ {
            static objCanvas;

            constructor(canvasMain, canvasScrollVert, canvasScrollHorz) {
                this.canvasMain = canvasMain;
                this.ctxMain = canvasMain.getContext("2d");
                this.mainHeight = canvasMain.height;
                this.mainWidth = canvasMain.width;

                this.canvasScrollVert = canvasScrollVert;
                this.canvasScrollHorz = canvasScrollHorz;

                this.ctxMain.font = "10pt Arial,sans-serif";

                this.error = false;
                this.message1 = "";
                this.message2 = "";
                this.firstSem = null;

                // Set up the last possible semesters and set the last display semester to it.
                let curDate = new Date();
                let curYear = curDate.getFullYear();
                let curMonth = curDate.getMonth();
                this.lastSem = new Semester(curMonth, curYear);
                this.lastPossibleSem = new Semester(curMonth, curYear);

                this.colorNames = rgb(16, 4, 177);
                this.colorBlack = rgb(0, 0, 0);

                this.bigFaculty = this.parse();
                if (this.bigFaculty != null) {
                    this.faculty = this.bigFaculty.copy();
                    this.faculty.sort(BYFIRSTSEMESTER);
                    this.firstPossibleSem = this.faculty.element(0).firstSemester();
                    this.firstSem = this.firstPossibleSem;
                    this.faculty.sort(BYNAME);
                }
                this.charWidth = this.stringWidth('1');
                // The Java applet used 2 + charWidth, but in order to recreate its appearance,
                // I had to use 1 + charWidth.
                this.widthOne = 1 + this.charWidth;
                this.fontHeight = computeFontHeight(this.ctxMain);
                this.beginy = 6 * this.fontHeight + 5;
                this.beginx = 150;
                this.liney = this.fontHeight;
                this.startVerticals = 6 * this.fontHeight;
                this.maxTitleWidth = 20 * this.stringWidth("1")
                // This is the color of the vertical bars. The original code used
                // Color.brighter(), which isn't available in JavaScript. I got this
                // by running the original code and using a color picker.
                this.colorVertical = "#d41405";

                CSCanvas.objCanvas = this;

                // Create objects to handle the vertical and horizontal scrollbars.
                var maxLines = this.faculty.size();
                // Set the number of lines per scroll of the page to one less than
                // the number of lines that fit in the canvas, so that the last
                // line on one page will be the first line on the next page.
                var linesPerPage = Math.trunc((this.mainHeight - 5) / this.fontHeight);
                // Account for the 5 header lines at the top that don't scroll.
                linesPerPage -= 5;
                // Normally I'd design the app to scroll by a page at a time, but the
                // original scrolls by only 10 lines at a time, for some reason.
                var linesPerScroll = 10;
                this.scrollbarVert = new CSScrollbar(this.canvasScrollVert, this.canvasMain,
                    maxLines, linesPerPage, linesPerScroll, true, function() {
                        CSCanvas.objCanvas.paintCanvas();
                    });
                this.scrollbarVert.draw();

                var sems= Semester.difference(this.firstSem,this.lastSem) + 1;
                this.scrollbarHorz = new CSScrollbar(this.canvasScrollHorz, this.canvasMain,
                    sems, 10, 10, false, function() {
                        CSCanvas.objCanvas.paintCanvas();
                    });
                this.scrollbarHorz.draw();

                document.getElementById("btnabout").addEventListener("click", function() {
                    document.getElementById("dlgAbout").showModal();
                });
            }

            // Calculate the number horizontal pixels of the given string,
            // using the current font.
            stringWidth(s) {
                return this.ctxMain.measureText(s).width;
            }

            // Set the color to be used for text and lines.
            // color is an HTML-style color name such as "red", or value, 
            // such as #ff0000.
            setColor(color) {
                this.ctxMain.fillStyle = color;
                this.ctxMain.strokeStyle = color;
                this.savedColor = color;
            }

            // Return the current color, as an HTML string.
            getColor() {
                return this.savedColor;
            }

            // Render the given string at position (x,y), using the current color.
            drawString(ctx, s, x, y) {
                ctx.fillText(s, x, y);
            }

            // Draw a line from (x1, y1) to (x2,y2) using the current color.
            drawLine(ctx, x1, y1, x2, y2) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Draw the entire canvas, including headers and faculty members.
            paintCanvas() {
                if (this.error) {
                    // An error message occurred. print it and return.
                    this.drawString(this.ctxMain, "Sorry, there is an error in the input.", 2, this.liney);
                    this.drawString(this.ctxMain, this.message1, 2, this.liney + this.fontHeight);
                    this.drawString(this.ctxMain, this.message2, 2, this.liney + 2 * this.fontHeight);
                }

                this.ctxMain.fillStyle = rgb(250,250,210);  // Light yellow
                this.ctxMain.fillRect(0, 0, canvasMain.width, canvasMain.height);

                // Calculate the first semester, firstSemScrolled, to appear in the
                // horizontally scrolled canvas
                this.firstSemScrolled = this.firstSem;
                var temp = this.scrollbarHorz.curLine;
                for (var i=0; i<temp; i= i+1) this.firstSemScrolled= this.firstSemScrolled.next();
                this.liney = this.fontHeight;
                this.paintLegend();
                this.printHeaders(3 * this.liney);
                this.beginy = 6 * this.fontHeight + 5;
                this.liney = this.beginy;
                this.scrollbarVert.setMaxLines(this.faculty.size());
                this.drawFaculty(this.faculty);
                this.drawVerticals();
            }

            // Display the headers that indicate the semester and year for each column.
            printHeaders(liney) {
                let saveColor = this.getColor();
                this.setColor(this.colorBlack);
                let s = this.firstSemScrolled;
                let xF = this.beginx;
                //invariant: Semesters less than s have been printed;
                //           the "F" or "S" for the semester goes at horizontal
                //           position xF and vertical position beginy                
                while (Semester.lesseq(s, this.lastSem)) {
                    // The original code used xF+1, but that put the semester letter
                    // too far to the right.
                    this.drawString(this.ctxMain,s.semester(), xF, liney);
                    let j = s.year() % 100;
                    this.drawString(this.ctxMain,((j - j % 10) / 10).toString(), xF, liney + this.fontHeight);
                    this.drawString(this.ctxMain,(j % 10).toString(), xF, liney + 2 * this.fontHeight);
                    xF = xF + this.widthOne;
                    s = s.next();
                }
                liney = liney + 3 * this.fontHeight;
                this.setColor(saveColor);
            }

            // Paint the elements of faculty beginning at vertical position liney
            // and advance liney accordingly.
            // Draw only one page's worth.  Headers are not included.
            drawFaculty(faculty) {
                let saveColor = this.getColor();
                // Set i to the index of the first faculty member to paint.
                // This is the value of the vertical scrollbar.
                var i = this.scrollbarVert.curLine;
                let maxi = Math.trunc(i + (this.mainHeight - 5) / this.fontHeight + 1 - 5);
                if (maxi > faculty.size()) maxi = faculty.size();
                // Invariant: i faculty have been painted, and number i goes at
                // y-coordinate liney                
                while (i < maxi) {
                    this.paintFaculty(faculty.element(i));
                    i = i + 1;
                    this.liney = this.liney + this.fontHeight;
                }
                this.setColor(saveColor);
            }

            // Paint faculty member f
            paintFaculty(f) {
                this.setColor(this.colorNames);
                // Draw the name, along with the number of semesters if the faculty are being sorted
                // by number of semesters
                // Store in st the prefix of the name that fits in given space and
                // in suffix either "" or the number of years in service                
                let st = f.name;
                let suffix = "";
                if (this.sortMethod == BYLENGTH) {
                    suffix = " " + f.numSemesters() / 2.0;
                    // Append ".0" to the number if it's an integer
                    if(!suffix.includes('.')) {
                        suffix += ".0";
                    }
                }

                // The original code truncated the name to fit in the canvas, assuming
                // a fixed-width font. However, in practice, the applet used a variable-width
                // font, so the truncation was not accurate. 
                // Literal translation of the original code:
                //    let noChars = ((this.beginx) / this.charWidth) - suffix.length - 4;
                //    if (st.length > noChars)
                //        st = st.substring(0, noChars - 1);
                // Thus, I'm going to compute the actual text length on the canvas and 
                // truncate the name accordingly.
                while(this.stringWidth(st + suffix) > (this.beginx - 2*this.charWidth)) {
                    st = st.substring(0, st.length - 1);
                }

                this.drawString(this.ctxMain, st + suffix, 2, this.liney);

                // Paint the periods of service for f
                let iter = new LinkedListIterator(f.periods);
                let previous = null;
                // Invariant: iter.data() is the next TitleTime to (possibly) paint for
                //            this faculty member, and previous is the previous
                //            TitleTime (null if none). TitleTimes before iter.data()
                //            have been printed.                
                while (iter.okay()) {
                    let tt = iter.data();
                    iter.next();
                    let next = null;
                    if (iter.okay())
                        next = iter.data();
                    this.paintPeriod(previous, tt, next);
                    previous = tt;
                }
                this.firstThreeDots(f);
                this.lastThreeDots(f);
                // Print the name on the right
                let diff = Semester.difference(this.firstSemScrolled, this.lastSem);
                let k = this.beginx + (diff + 1) * this.widthOne + 2 * this.widthOne;
                this.drawString(this.ctxMain, f.name, k, this.liney);
            }

            // Display the total number of faculty members and for the current filter,
            // the number of faculty members with each title. Also display the
            // legend for the types of leave, if there are any faculty members 
            // in the filter with that type of leave.
            paintLegend() {
                // Note: this "No. of faculty:" text never actually showed up on the Java applet. 
                // Dunno why.
                this.ctxMain.fillStyle = rgb(0, 0, 0);
                let cm = 2;
                let liney = this.fontHeight;
                let msg = "No. of faculty: " + this.faculty.size();
                this.drawString(this.ctxMain, msg, cm, this.fontHeight * 3);

                let noOnLine = 0;
                let tt = 1;
                while (tt <= TitleTime.numTitles) {
                  if (this.someoneHas(tt)) {
                    let n = this.faculty.numTitle(tt);
                    let title = TitleTime.makeTitle(tt);
                    let num = this.faculty.numTitle(tt);
                    this.setColor(TitleTime.titleColor(tt));
                    this.drawString(this.ctxMain, title + " (" + num + ")  ", cm, liney);
                    cm = cm + this.maxTitleWidth;
                    noOnLine = noOnLine + 1;
                    if (noOnLine == 4) {
                      liney = liney + this.fontHeight;
                      noOnLine = 0;
                      cm = 2;
                    }
                  }
                  tt = tt + 1;
                }
                if (this.someoneHasStatus(TitleTime.SABBATIC)) {
                  liney = 4 * this.fontHeight;
                  cm = 2;
                  this.drawString(this.ctxMain, "sabbatic: ", cm, liney);
                  cm = cm + this.stringWidth("sabbatic: ");
                  this.setColor(TitleTime.titleColor(TitleTime.FULLPROF));
                  this.drawStatusLines(this.ctxMain, cm, cm + 10, TitleTime.NOLEAVE, liney);
                  this.drawStatusLines(this.ctxMain, cm + 11, cm + 28, TitleTime.SABBATIC, liney);
                  this.drawStatusLines(this.ctxMain, cm + 29, cm + 38, TitleTime.NOLEAVE, liney);
                }
                if (this.someoneHasStatus(TitleTime.OTHERLEAVE)) {
                    liney = 5 * this.fontHeight;
                    cm = 2;
                    this.drawString(this.ctxMain, "leave: ", cm, liney);
                    cm = cm + this.stringWidth("sabbatic: ");
                    this.setColor(TitleTime.titleColor(TitleTime.FULLPROF));
                    this.drawStatusLines(this.ctxMain, cm, cm + 10, TitleTime.NOLEAVE, liney);
                    this.drawStatusLines(this.ctxMain, cm + 11, cm + 28, TitleTime.OTHERLEAVE, liney);
                    this.drawStatusLines(this.ctxMain, cm + 29, cm + 38, TitleTime.NOLEAVE, liney);
                }
            }
            
            // Draw lines in horizontal position h1..h2 for leave status st at liney,
            // for the current faculty member.
            drawStatusLines(ctx, h1, h2, st, liney) {
                if (st == TitleTime.SABBATIC) {
                } else {
                    this.drawLine(ctx, h1, liney - 5, h2, liney - 5);
                    this.drawLine(ctx, h1, liney - 4, h2, liney - 4);
                }
                if (st == TitleTime.OTHERLEAVE) {
                } else {
                    this.drawLine(ctx, h1, liney - 3, h2, liney - 3);
                    this.drawLine(ctx, h1, liney - 2, h2, liney - 2);
                }
            }

            // Set the color for the first three dots for faculty f.
            // Then, paint the first three dots for faculty f if at least part
            // of the first time period cannot painted
            firstThreeDots(f) {
                let first = f.periods.inspect();
                this.setColor(first.titleColor());
                if (this.isWithin(first) && Semester.lesseq(this.firstSem, f.firstSemester())) {
                    return;
                }
                this.drawString(this.ctxMain, " ...", this.beginx - 18, this.liney - 4);
            }

            // Set the color for the title of the last time period of f.
            // Then, paint the last three dots for faculty f if at least part
            // of the last time period cannot painted
            lastThreeDots(f) {
                let last = f.periods.inspectLast();
                this.setColor(last.titleColor());
                if (this.isWithin(last) && Semester.lesseq(f.lastSemester(), this.lastSem)) {
                    return;
                }
                // Set k to the horizontal position for the last three dots
                let diff = Semester.difference(this.firstSemScrolled, this.lastSem);
                let k = this.beginx + (diff + 1) * this.widthOne - 1;
                this.setColor(last.titleColor());
                this.drawString(this.ctxMain, " ...", k + 2, this.liney - 4);
            }

            // Paint a single period of service for a faculty member.  Use a horizontal line
            // that is aligned with the beginning and ending semesters of the period.
            // Paint period tt if (part of) it is within firstSemScrolled..lastSem.
            // previous is the previous period (null if none) and n is the next
            // period (null if none)
            paintPeriod(previous, tt, next) {
                if (!this.isWithin(tt))
                    return;
                // Calculate position j of beginning of line for time period tt
                let sTemp = Semester.max(this.firstSemScrolled, tt.firstSemester);
                sTemp = Semester.min(this.lastSem, sTemp);
                let j = this.beginx + Semester.difference(this.firstSemScrolled, sTemp) * this.widthOne;
                j = j + this.widthOne / 2 - 2;

                // if the line for the previous period should be contiguous with
                // this one, subtract a bit from j so that the lines will abut
                if ((previous != null) &&
                    this.isWithin(previous) &&
                    Semester.equals(previous.lastSemester.next(),
                        tt.firstSemester)) {
                    j = j - this.widthOne / 2 + 1;
                }

                // Calculate position k of end of line for time period tt
                sTemp = Semester.min(this.lastSem, tt.lastSemester);
                sTemp = Semester.max(this.firstSemScrolled, sTemp);
                let k = this.beginx + Semester.difference(this.firstSemScrolled, sTemp) * this.widthOne;
                // Original code divided by 3, but that made the lines too short.
                k = k + this.widthOne / 2; 
                // if the line for the next period should be contiguous with
                // this one, add a bit to k j so that the lines will abut
                if ((next != null) &&
                    this.isWithin(next) &&
                    Semester.equals(next.firstSemester,
                        tt.lastSemester.next())) {
                    k = k + this.widthOne / 2;
                }

                // Draw the lines for this period
                this.setColor(tt.titleColor());
                this.drawStatusLines(this.ctxMain, j, k, tt.status, this.liney);
            }

            // = "period given by tt is at least partly within firstSem..lastSem
            isWithin(tt) {
                if (Semester.less(tt.lastSemester, this.firstSem))
                    return false;
                if (Semester.less(this.lastSem, tt.firstSemester))
                    return false;
                return true;
            }

            // = "some faculty member has title tt (a constant of class TitleTime)
            //   in a period covered by firstSem..lastSem"
            someoneHas(tt) {
                for (let i = 0; i != this.faculty.size(); i = i + 1) {
                    let f = this.faculty.element(i);
                    let iter = new LinkedListIterator(f.periods);
                    while (iter.okay()) {
                        if (this.isWithin(iter.data()) &&
                            iter.data().title == tt) {
                            return true;
                        }
                        iter.next();
                    }
                }
                return false;
            }

            // = "some faculty member has status st (one of the status constants of TitleTime)
            //   in a period covered by firstSem..lastSem"
            someoneHasStatus(st) {
                for (let i = 0; i != this.faculty.size(); i = i + 1) {
                    let f = this.faculty.element(i);
                    let iter = new LinkedListIterator(f.periods);
                    while (iter.okay()) {
                        if (this.isWithin(iter.data()) &&
                            iter.data().status == st) {
                            return true;
                        }
                        iter.next();
                    }
                }
                return false;
            }

            // Read and return the status and title information (or ".") from t for
            // person name. The input is either
            //    (0) a period "."
            //    (1) one of L, SL, I, A1,A2, FP, EP, F
            //    (2) SAB followed by one of L, SL, I, A1,A2, FP, EP, F
            //    (3) LEA  followed by one of L, SL, I, A1,A2, FP, EP, F
            // If the next title is wrong, print a message and return -1
            // Because oly one value is returned, the returned value is
            // coded as follows:
            //    case (0) return 0
            //    case (1) return the TitleTime constants for the value
            //    case (2) return 15 + (TitleTime constants for the value)
            //    case (3) return 30 + (TitleTime constants for the value)
            readTitle(t, name) {
                let ret = 0;
                let token = t.nextWord();
                if (token==".") return 0;
                if (token=="SAB") {
                    ret = 15;
                    token = t.nextWord();
                } else if (token=="LEA") {
                    ret = 30;
                    token = t.nextWord();
                }
                if (token=="L") return ret + TitleTime.LECTURER;
                if (token=="SL") return ret + TitleTime.SRLECTURER;
                if (token=="I") return ret + TitleTime.INSTRUCTOR;
                if (token=="A1") return ret + TitleTime.ASSTPROF;
                if (token=="A2") return ret + TitleTime.ASSOCPROF;
                if (token=="FP") return ret + TitleTime.FULLPROF;
                if (token=="EP") return ret + TitleTime.EMERITUS;
                if (token=="F") return ret + TitleTime.FIELD;
                this.error = true;
                this.message1 = " A title for " + name +
                    " is wrong; it is \"" + token + "\"";
                return -1;
            }

            // = Last title in the range firstSem..lastSem for faculty f
            // (the title is one of the constants in TitleTime)
            // Precondition: at least one TitleTIme for f is within the range
            lastTitle(f) {
                let iter = new LinkedListIterator(f.periods);
                // Store in p the first element of periods that is within
                // firstSem.lastSem and set iter.data() to the next one
                while (!this.isWithin(iter.data())) {
                    iter.next();
                }
                let p = iter.data();
                // Change p to the last TitleTime that is within firstSem..lastSem
                //invariant: p is within firstSem..lastSem and iter.data()
                //           is the next TitleTime on the list (null if none)                
                iter.next();
                while (iter.okay() && this.isWithin(iter.data())) {
                    p = iter.data();
                    iter.next();
                }
                return p.title;
            }

            // Read the next time period for person name from t into s1 and s2
            // If there is any error in the input, print a message and set the year of s1 to -1
            readPeriod(t, name, s1, s2) {
                let bSemester = t.nextWord();  // The first semester (F or S)
                if (!this.isForS(bSemester)) {
                    this.error = true;
                    this.message1 = "A token following " + name +
                        " is not \"F\" or \"S\";";
                        this.message2 = "it is \"" + bSemester + "\"";
                    s1.setYear(-1);
                    return;
                }
                s1.setSemester(bSemester);
                let bYear = t.nextIntToken();  // The first year
                if (bYear == -1) {
                    this.error = true;
                    this.message1 = "The first year for name " + name + " is not an integer.";
                    s1.setYear(-1);
                    return;
                }
                s1.setYear(bYear);
                let eSemester = t.nextWord();   // Either the last semester (F or S)
                                                // or the "present"
                let eYear;                      // The last year
                if (eSemester == "present") {
                    s2.setSemester(this.lastPossibleSem.semester());
                    s2.setYear(this.lastPossibleSem.year());
                } else {
                    if (!this.isForS(eSemester)) {
                        this.error = true;
                        this.message1 = "The last semester for " + name + "is not \"F\" or \"S\";";
                        this.message2 = "it is \"" + eSemester + "\"";
                        s1.setYear(-1);
                        return;
                    }
                    eYear = t.nextIntToken();
                    if (eYear == -1) {
                        this.error = true;
                        this.message1 = "The last year for name " + name + " is not an integer.";
                        s1.setYear(-1);
                        return;
                    }
                    s2.setSemester(eSemester);
                    s2.setYear(eYear);
                }
            }

            // = s consists solely of digits 0..9
            isDigits(s) {
                for (let i = 0; i != s.length(); i = i + 1) {
                    if (s.charAt(i) < '0') return false;
                    if (s.charAt(i) > '9') return false;
                }
                return true;
            }

            // = s is "F" or "S"
            isForS(s) {
                return (s=="F" || s=="S");
            }

            // Construct and return a DynArray with the data from input.
            // The input is in file faclist.txt.
            // Input must have the format described in class Facultylists
            // Return null if there is an error in the input
            parse() /* returns a DynArray */ {
                let d = new DynArray();
                let t = new GriesTokenizer(strFacList);
                // Invariant: d contains the faculty data parsed thus far;
                //            the current token is either TT_EOF or the first datum
                //            for the next faculty  member to get from the input is
                //            in ttype-nval-sval                
                while (t.hasMoreTokens()) {
                    let name = t.nextWord().replaceAll('=', ' ');
                    // Read in title and leave info into title and status
                    let title = this.readTitle(t, name);
                    if (title == -1) return null;
                    let status = TitleTime.NOLEAVE;
                    if (title > 30) {
                        status = TitleTime.OTHERLEAVE;
                        title = title - 30;
                    }
                    if (title > 15) {
                        status = TitleTime.SABBATIC;
                        title = title - 15;
                    }
                    let s1 = new Semester();
                    let s2 = new Semester();
                    this.readPeriod(t, name, s1, s2);
                    if (s1.year() == -1) return null;
                    let f = new Faculty(name, title, status, s1, s2);
                    title = this.readTitle(t, name);
                    // invariant: d contains all periods for name that have been read
                    //            in so far and title contains the next token
                    //            of the input (0 for ".", -1 for error, and
                    //            one of the constants from from TitleTime otherwise                    
                    while (title != 0) {
                        // Break title into its title and status
                        if (title == -1) return null;
                        status = TitleTime.NOLEAVE;
                        if (title > 30) {
                            status = TitleTime.OTHERLEAVE;
                            title = title - 30;
                        }
                        if (title > 15) {
                            status = TitleTime.SABBATIC;
                            title = title - 15;
                        }
                        s1 = new Semester();
                        s2 = new Semester();
                        this.readPeriod(t, name, s1, s2);
                        if (s1.year() == -1) return null;
                        f.addPeriod(title, status, s1, s2);
                        title = this.readTitle(t, name);
                    }
                    d.add(f);
                }
                return d;
            }

            // Paint vertical lines every ten semesters and after the last semester
            drawVerticals() {
                let saveColor = this.getColor();
                this.setColor(this.colorVertical);
                // y-coordinate of top of a vertical line
                let topy = this.startVerticals;
                let i = 0;
                let diff = Semester.difference(this.firstSemScrolled, this.lastSem);
                // Invariant: vertical lines before year i have been painted
                while (i <= diff) {
                    // Calculate x-coordinate k just before semester i
                    let k = this.beginx + i * this.widthOne - 1;
                    this.drawLine(this.ctxMain, k, topy, k, this.liney - this.fontHeight);
                    i = i + 10;
                }
                // Paint a vertical line after the last year
                let k = this.beginx + (diff + 1) * this.widthOne - 1;
                this.drawLine(this.ctxMain, k, topy, k, this.liney - this.fontHeight);
                this.setColor(saveColor);
            }

            // Reset the vertical and horizontal scrollbars to their initial positions,
            // and reset the number of lines covered by the vertical scrollbar.
            resetScrollbars() {
                this.scrollbarVert.curLine = 0;
                this.scrollbarVert.maxLines = this.faculty.size();
                this.scrollbarHorz.curLine = 0;
            }

            // Store in array faculty people from academic years fy to ly.
            // Sort the faculty depending on sortChoice (a constant BYNAME .. BYTITLE)
            recalculate(sortChoice, fy, ly) {
                this.firstSem = Semester.min(new Semester(9, fy), this.lastPossibleSem);
                this.lastSem = Semester.min(new Semester(0, ly + 1), this.lastPossibleSem);
                this.faculty = this.bigFaculty.copy();
                let j = 0;
                while (j != this.faculty.size()) {
                    let fac = this.faculty.element(j);
                    let out = Semester.less(fac.lastSemester(), this.firstSem) ||
                    Semester.less(this.lastSem, fac.firstSemester());
                    if (out) {
                        this.faculty.remove(j);
                    } else {
                        fac.lastTitle = this.lastTitle(fac);
                        j = j + 1;
                    }
                }
                this.faculty.sort(sortChoice);
                this.sortMethod = sortChoice;
            }
        }  // end of class CSCanvas

        // Populate a select element with years from 1965 to 1998, inclusive.
        // id   is the DOM id of the select element.
        // yearToSelect is the year to select by default.
        function initSelect(id, yearToSelect) {
            var select = document.getElementById(id);
            for (var year = 1965; year <= LASTYEAR; year++) {
                var option = document.createElement("option");
                option.value = year;
                option.text = year;
                if(year === yearToSelect) {
                    option.selected = true;
                }
                select.appendChild(option);
            }
        }

        // Initialize the HTML.
        function initHTML() {
            // Populate the year select elements.
            initSelect("selfirst", 1965);
            initSelect("sellast", LASTYEAR);
        }

        // Given the id of an HTML select element, select the supplied option.
        function setSelectOption(idSelect, valueToSelect) {
            // Get a reference to the select element
            var selectElement = document.getElementById(idSelect);

            // Loop through the options in the select element to find the one we want.
            for (var i = 0; i < selectElement.options.length; i++) {
                // If the current option is the one we want to select, select it.
                if (selectElement.options[i].text === valueToSelect) {
                    selectElement.options[i].selected = true;
                    break;
                }
            }
        }

        // Handle a click on the OK button, which causes us to redisplay the
        // faculty with the new filter and sorting criteria.
        function onOK() {
            let canvas = CSCanvas.objCanvas;

            let fy = parseInt(document.getElementById("selfirst").value);
            let ly = parseInt(document.getElementById("sellast").value);
            if (fy > ly) {
                // The  first year is later than the last year; correct this by
                // changing the last year to the first year. Also reflect this
                // in the UI.
                ly= fy;
                setSelectOption("sellast", ly.toString());
            }
            let sortChoiceText = document.getElementById("selsortby").value;
            let sortChoice = BYNAME;
            switch(sortChoiceText) {
                case "name": sortChoice = BYNAME; break;
                case "first semester": sortChoice = BYFIRSTSEMESTER; break;
                case "last semester": sortChoice = BYLASTSEMESTER; break;
                case "time in dept.": sortChoice = BYLENGTH; break;
                case "title": sortChoice = BYTITLE; break;
                default: alert("Invalid sort choice: " + sortChoiceText); break;
            }
            
            canvas.recalculate(sortChoice, fy, ly);
            canvas.resetScrollbars();
            canvas.paintCanvas();
        }

        // Main function called at startup.
        function main() {
            initHTML();
            var canvasMain = document.getElementById("canvasMain");
            var canvasScrollVert = document.getElementById("scrollbarVert");
            var canvasScrollHorz = document.getElementById("scrollbarHorz");
            var canvas = new CSCanvas(canvasMain, canvasScrollVert, canvasScrollHorz);
            onOK();
        }
        main();
    </script>
</body>

</html>